---
title: "LCC2005"
author: "Alex Chubaty"
date: "05 January 2015"
output: html_document
---

This file will run a set of 6 "toy" SpaDES modules (i.e., they do not predict anything real) that simulate:
1. Caribou movement,
2. Fire burning,
3. Forest vegetation succession,
4. Forest aging,
5. Several GIS operations,
6. Some data operations.

In order to do this, we will walk through 5 steps:

0. Install and load necessary R packages
1. Download modules and data from the internet. Unzip one zipped data file,
2. Pick a random polygon somewhere in Canada on which to run the dynamic model,
3. Initiate a simList object (a simulation object which contains details of the dynamic model),
4. Run the simualtion.

We have grouped these 6 modules into a single "parent" or group module called "LCC2005". 
This metamodule is simply a convenience so we don't have to specifically type the names of 
all six modules. So, when we write LCC2005 as a module name, it is simply a shorthand 
for selecting the six child modules named:

1. `caribouMovementLcc`
2. `fireSpreadLcc`
3. `forestSuccessionBeacons`
4. `forestAge`
5. `cropReprojectLccAge`
6. `LccToBeaconsReclassify`

These modules can work together because their metadata are mutually compatible (we made them that way). 
These modules actually have 2 different time units (month for caribou, year for others): the SpaDES package can weave these modules together in spite of this mismatch. 
This is because their time units are declared in their metadata. 
(We will not look into the metadata in this file. That is for more advanced examples.)

The code in this file downloads all modules and data required to run a dynamic model. 
This will be run at the end of this file using a call to the spades function.

(If you are running this on a Windows OS, the visualizations will be quick because a device will be opened that is not within RStudio.
On a Linux on OS X machine, this will not occur, so visualization will be slow because the RStudio graphics device is slow).

Step 0: Load R packages
```{r package}
library(igraph)
library(raster)
library(SpaDES)
library(rgdal)
library(rgeos)

# Use install.packages("igraph") etc. for each package that you do not have.

```

Step 1: Download modules and data
```{r download-modules, eval=TRUE}
# Step 1 - download some modules from SpaDES-Modules cloud repository to your computer
#  A box will pop up for you to select a destination for these modules. It should be
#  easy
if (!exists("baseDir")) {
  baseDir <- if ( interactive() && (Sys.info()[["sysname"]] == "Windows") ) {
    choose.dir(caption = "Select a directory to download some simple modules and data")
  } else {
    file.path(tempdir(), "modules")
  } %>% checkPath(create = TRUE)
}

downloadModule("LCC2005", baseDir) # default `data=FALSE` doesn't download data, 
                                   # because data is large
downloadData("LCC2005", baseDir) # download data as a separate step, solely so user 
                                 # has more control over process. Alternatively, use 
                                 # `data=TRUE` above.
# The downloaded data from one of the modules, LccToBeaconsReclassify is zipped upon 
#  arrival. Must unzip it.
unzip(zipfile = file.path(baseDir, "LccToBeaconsReclassify", "data", "LandCoverOfCanada2005_V1_4.zip"),
      files = "LCC2005_V1_4a.tif",
      exdir = file.path(baseDir, "LccToBeaconsReclassify", "data"))

# load data into R. These are 2 Canada-wide maps
age <- raster::raster(file.path(baseDir, "forestAge", "data", "can_age04_1km.tif"))
lcc05 <- raster::raster(file.path(baseDir, "LccToBeaconsReclassify", "data",
                                  "LCC2005_V1_4a.tif"))
lcc05CRS <- crs(lcc05) # This is just the projection information. It will be used in the next chunk.

```


Step 2: Pick a random polygon
```{r model-inputs, eval=TRUE}
# Pick a subset area to run projections on. You can replace this with anything that 
#  will create a polygon inside the forested parts of Canada.
# Here we pick a random polygon. Centered here:
  areaKm2 <- 2000
  minX <- -1072250.2
  maxX <- minX + sqrt(areaKm2*1e6)
  minY <- 7438877-1.6e5
  maxY <- minY + sqrt(areaKm2*1e6)
  meanY <- mean(c(minY, maxY))
  
  # Add random noise to polygon
  set.seed(5567913)
  xAdd <- round(runif(1, -5e5, 1.5e6))
  yAdd <- round(runif(1, 1e5, 5e5)) - xAdd/2
  nPoints <- 20
  betaPar <- 0.6
  X = c(
    jitter(sort(rbeta(nPoints, betaPar, betaPar)*(maxX-minX)+minX)),
    jitter(sort(rbeta(nPoints, betaPar, betaPar)*(maxX-minX)+minX, decreasing = TRUE))
  )
  Y = c(
    jitter(sort(rbeta(nPoints/2, betaPar, betaPar)*(maxY-meanY)+meanY)),
    jitter(sort(rbeta(nPoints, betaPar, betaPar)*(maxY-minY)+minY, decreasing = TRUE)),
    jitter(sort(rbeta(nPoints/2, betaPar, betaPar)*(meanY-minY)+minY))
  )
  
  # Create the polygon
  inputMapPolygon <- cbind(X+xAdd, Y+yAdd) %>% 
    Polygon %>%
    list %>%
    Polygons("s1") %>%
    list %>%
    SpatialPolygons(1L)
  crs(inputMapPolygon) <- lcc05CRS
```

Now that we have downloaded a series of modules, the data on which they depend, and we have created a spatial area on which to run the dynamic simulations, we can start initiating the simList object.  
The simList object is special class of object. Its structure is defined in the SpaDES package. 
As users, we need to create a new simList for every model we want to run. 

We need to put several key things into the simList:

1. The **modules** that we will be running. We can specify a parent module if that exists, or we can list off all the individual child modules. Both will do the same thing.
2. The **times** (start and end) of our dynamic model. We should also give the time unit that we want to see our model in. In this case, the caribou module is in months and everything else is in years. If we want our model to be in years, we need to specify that.
3. The **paths** (where input files, output files, modules, and a cache path should be located).
4. Any **objects** that we want to load from an R environment (including the working, i.e,. the "global"" environment).
5. Any **parameters** that we want to update. Each module has a set of parameters defined in their metadata, as well as the default values for those parameters. We can accept those defaults (and not write anything here), or we can override them by specifying them here.

Here, we divide this initialization into two parts:

1. create all the necessary objects
2. pass these objects into the `simInit()` function

Step 3: Build simInit objects
```{r create objects for simInit, eval=TRUE}
# setup simList details
outputDir <- file.path(tempdir(), "simOutputs")
cacheDir <- checkPath(file.path(outputDir, "cache"), create = TRUE)

times <- list(start = 2005.0, end = 2020.0, timeunit = "year")
parameters <- list(
  .globals = list(burnStats = "nPixelsBurned"),
  .progress = list(type = "text", interval = 1),
  cropReprojectLccAge = list(useCache=TRUE),
  forestSuccessionBeacons = list(
    returnInterval = 1, startTime = times$start,
    .plotInitialTime = times$start, .plotInterval = 1),
  forestAge = list(
    returnInterval = 1, startTime = times$start+0.5,
    .plotInitialTime = times$start, .plotInterval = 1),
  fireSpreadLcc = list(
    nFires = 3, its = 1e6, drought = 1.2, persistprob = 0, returnInterval = 1,
    startTime = times$start+1, .plotInitialTime = times$start, .plotInterval = 1),
  caribouMovementLcc = list(
    N = 1e3, moveInterval = 1, startTime = times$start+1, torus = TRUE,
    glmInitialTime = NA_real_, .plotInitialTime = times$start, .plotInterval = 1)
)
modules <- list("LCC2005")
objects <- list(age = "age", lcc05 = "lcc05", inputMapPolygon = "inputMapPolygon")
paths <- list(
  cachePath = cacheDir,
  modulePath = baseDir,
  inputPath = baseDir,
  outputPath = outputDir
)

# Here is the simInit call, using the above objects. 
mySim <- simInit(times = times, params = parameters, modules = modules,
                 objects = objects, paths = paths)

```

Before we run the simulation, there are several tools in SpaDES that help us look at the simList.
```{r look at how modules fit together}
### Simulation overview: note the child modules are initialized
moduleDiagram(mySim)
objectDiagram(mySim)
```

Now that the `mySim` object has been initialized, we can run the simulation by calling
`spades`

Step 4: Run simulation using `spades()`
```{r run-SpaDES, eval=FALSE}
if ( interactive() && Sys.info()[["sysname"]] == "Windows" ) {
# Rstudio server plotting device is slow, but no alternative available on Linux types 
    dev() # This works on Windows
}

# First plot the Canada wide map, and the random polygon. This were also passed into the
#   simInit call, but the modules don't by default plot this.
Plot(lcc05, new = TRUE)
Plot(inputMapPolygon, addTo = "lcc05", gp = gpar(col = "yellow", lwd = 2))

spades(mySim)
```
